[参考专栏 | 设计模式之美](https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D)

[android开发模式/框架比较分析：从MVC到MVP到MVVM到Clean](https://blog.csdn.net/qq_23081779/article/details/90172901)

[Android Developer | 应用架构指南](https://developer.android.com/jetpack/guide?hl=zh-cn)

[本文链接](https://github.com/Jay-Droid/base-dev-design/blob/master/doc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Remix.md)

# Android 项目的架构

Talk is cheap，Show me the code！！！

## 架构准则

- 框架独立。架构不依赖于一些满载功能的软件库。
- 可测试性。
- UI独立，在不改变系统其余部分的情况下完成对UI的简易更改。
- 数据库独立，业务规则不绑定与某个具体的数据库当中，可以随意更换数据库的具体实现：比如说从SQL换到BigTable，这种情况不会对业务规则产生影响。
- 外部机制独立，业务规则完全不知道外层的事情。

- 分离关注点，要遵循的最重要的原则是**[分离关注点](https://en.wikipedia.org/wiki/Separation_of_concerns)**。一种常见的错误是在一个 `Activity` 或 `Fragment` 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应使这些类尽可能保持精简，这样可以避免许多与生命周期相关的问题。请注意，您并非拥有 `Activity` 和 `Fragment` 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，您最好尽量减少对它们的依赖。

- 通过模型驱动界面，另一个重要原则是您应该**通过模型驱动界面**（最好是持久性模型）。模型是负责处理应用数据的组件。它们独立于应用中的 [`View`](https://developer.android.com/reference/android/view/View?hl=zh-cn) 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。应用所基于的模型类应明确定义数据管理职责，这样将使应用更可测试且更一致。持久性是理想之选，原因如下：
  	- 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。
  	- 当网络连接不稳定或不可用时，应用会继续工作。





## 开发模式对比分析

|            | MVC                  | MVP                    | MVVM                         | MVPVM              | Clean              |
| ---------- | -------------------- | ---------------------- | ---------------------------- | ------------------ | ------------------ |
| 修改       | 3                    | 4                      | 5                            | 5                  | 5                  |
| 新增       | 3                    | 5                      | 4                            | 5                  | 5                  |
| 复用       | 3                    | 4                      | 4                            | 4                  | 5                  |
| 单元测试   | 3                    | 4                      | 5                            | 5                  | 4                  |
| UI测试     | 4                    | 4                      | 4                            | 4                  | 4                  |
| 学习成本   | 3                    | 4                      | 5                            | 5                  | 5                  |
| 代码复杂度 | 3                    | 4                      | 5                            | 5                  | 5                  |
| 实现复杂度 | 1                    | 3                      | 2                            | 4                  | 5                  |
| 代码量     | 1                    | 3                      | 2                            | 4                  | 5                  |
| 可读性     | 2                    | 4                      | 1                            | 4                  | 4                  |
| 可维护性   | 1                    | 3                      | 2                            | 4                  | 5                  |
| 优点       | 开发简单             | 模型视图分离，逻辑清晰 | 双向绑定，简洁清晰           | 逻辑清晰，耦合度低 | 耦合度极低         |
| 缺点       | 业务增加后，不易维护 | 抽象接口较多           | 可读性较差，出现问题不易定位 | 实现业务复杂度高   | 业务实现复杂读极高 |
| 适用场景   | 极小型项目           | 中大型项目             | 中大型项目                   | 大型项目           | 超大型项目         |

![](https://tva1.sinaimg.cn/large/0081Kckwly1glxn578w4yj30qo0k00t9.jpg)

## MVC

### 架构介绍

MVC模式的意思是，软件可以分成三个部分，三个部分的通信都是单向的。

- Model：数据模型层，主要负责数据的获取
- View：视图层，页面的显示，即xml
- Controller：控制器，业务逻辑的核心控制，即activity/fragment

Android 中的MVC模式弱化了Controller的概念，将Controller和View的责任都交给了Activity。

### 模型联系

![](https://tva1.sinaimg.cn/large/0081Kckwly1glwm74z5emj31g80gyjuc.jpg)

View --> Controller，也就是反应View的一些用户事件（点击触摸事件）到Activity上。

Controller --> Model, 也就是Activity去读写一些我们需要的数据。

Model --> View, 也就是Activity在获取数据之后，将更新内容反映到View上。

### 代码实现

//todo

### 优缺点

- 从MVC的结构来看，Android本身的设计就符合MVC架构，但是Android中纯粹作为V层的XML视图功能太弱，我们不得不将大量处理View的逻辑写在Activity中，这样Activity就充当了View和Controller两个角色，最终导致Activity中的代码激增。这样看来Android项目本身的设计应该称为MV架构。
- Activity中代码过度积累会导致后期项目的维护和扩展工作很难展开

- 控制层和View层都在activity中进行操作，数据操作方便，类文件少，可以快速完成某项功能，适合小体量的项目

### MVC增强

Android 中传统的MVC结构并没有显式分开 View 和 Controller的任务，可以考虑创建Controller层分离出Activity中的大部分业务逻辑代码

合理采用设计原则，如 基于接口而非实现编程等可以有效提高架构的扩展性。



## MVP

### 架构介绍

在MVC架构中因为Activity就充当了View和Controller两个角色导致Activity中的代码和逻辑比较臃肿，所以MVP架构就是从原来的Activity

层把view和Controller区分开，单独抽出来一层Presenter作为原来Controller的职位，利用接口回调的方式实现V层与P层的交互，也实现了V层和M层彻底解耦

- Model：数据模型层，主要负责数据的获取
- View：视图层，页面的显示，即xml+activity/fragment
- Presenter：控制器，业务逻辑的核心控制

### 模型联系

![](https://tva1.sinaimg.cn/large/0081Kckwgy1glwry251dzj31f20j2adp.jpg)

View --> Presenter，反应View的一些用户事件到Presenter上。

Presenter --> Model, Presenter去读写操作一些我们需要的数据。

Presenter --> View, Presenter在获取数据之后，将更新内容反馈给Activity，进行view更新。

### 代码实现

//todo

### 优缺点

- 易扩展/维护：M与V完全分离，由P负责控制和M与V之间的交互工作，从而可以修改V层而不影响M层，添加功能只需依赖相应的接口就可实现，有利于项目的维护与扩展

- P层可服用：我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑

- P层易测试：把逻辑放在Presenter中并且用接口隔离V层，可以脱离用户接口对这些逻辑进行单元测试

- Activity 减负：Presenter中分离了Activity中的大部分逻辑，让Activity主要承担一个更新View的工作



- 代码量大大增加了，每个页面或者说功能点，都要专门写一个Presenter类，并且由于是面向接口编程，需要增加大量接口，会有大量繁琐的回调。
- 由于Presenter里持有了Activity对象，所以可能会导致内存泄漏或者view空指针。
- P层与V层是通过接口进行交互的，接口粒度不好控制。粒度太小，就会存在大量接口的情况，使代码太过碎版化；粒度太大，解耦效果不好
- MVP是以UI和事件为驱动的模型，更新UI都需要保证能获取到控件的引用，同时更新UI的时候要考虑当前是否是UI线程，也要考虑Activity的生命周期（是否已经销毁等）。数据都是被动地通过UI控件做展示，缺乏灵活性和自动性。
- V层与P层还是有一定的耦合度。一旦V层某个UI元素更改，那么对应的接口就必须得改，数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。



## CLEAN

### 架构介绍

Clean 一般是指，代码以洋葱的形状依据一定的依赖规则被划分为多层：内层对于外层一无所知。这就意味着依赖只能由外向内。

该项目主要分为以下几个模块：

- domain：抽象业务层，隔离数据层与表现层
- data：数据层，提供应用所需的所有数据
- presentation：表现层，是MVX结构所对应的地方（MVC、MVP等），这里不处理UI以外的任何逻辑。

### 模型联系

**表现层 (Presentation Layer)**：表现层可以用MVC、MVP或MVVM等模式。这里的fragment和activity都是View,其内部除了UI逻辑以外没有其他逻辑，这也是所有渲染的东西都放在这里。如果表现层采用MVP实现，那么本层次的Presenter由多个interactor（用例）组成，Presenter在 android UI 线程以外的新线程里工作，并通过回调将要渲染到View上的数据从里面（data-domain）传递回来。

**抽象业务层 (Domain Layer)**：这里的业务规则是指所有在本层发生的逻辑。对于Android项目来说，大家还可以看到所有的interactor（用例）实施。这一层是纯粹的java模块，没有任何的Android依赖性。当涉及到业务对象时，所有的外部组件都使用接口。

**数据层 (Data Layer)**：应用所需的所有数据都来自这一层中的UserRepository实现（接口在领域层）。这一实现采用了[Repository Pattern](http://link.zhihu.com/?target=http%3A//martinfowler.com/eaaCatalog/repository.html)，主要策略是通过一个工厂根据一定的条件选取不同的数据来源。
 比如，通过ID获取一个用户时，如果这个用户在缓存中已经存在，则硬盘缓存数据源会被选中，否则会通过向云端发起请求获取数据，然后存储到硬盘缓存。
 这一切背后的原理是由于原始数据对于客户端是透明的，客户端并不关心数据是来源于内存、硬盘还是云端，它需要关心的是数据可以正确地获取到。



### 代码实现

//todo

### 优缺点



## MVVM

[美团技术团队 ｜ 如何构建Android MVVM 应用框架](https://tech.meituan.com/2016/11/11/android-mvvm.html)

### 架构介绍

MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。它非常完美的解耦了View层和ViewModel，解决了MVP的痛点。

**View: **视图层，对应于Activity和XML，负责View的绘制以及与用户交互。 

**Model:** 数据模型层，主要负责数据的获取

**ViewModel: **控制器，负责完成View与Model间的交互，业务逻辑的核心控制

#### 数据驱动

在常规的开发模式中，数据变化需要更新UI的时候，需要先获取UI控件的引用，然后再更新UI。获取用户的输入和操作也需要通过UI控件的引用。在MVVM中，这些都是通过数据驱动来自动完成的，数据变化后会自动更新UI，UI的改变也能自动反馈到数据层，数据成为主导因素。这样MVVM层在业务逻辑处理中只要关心数据，不需要直接和UI打交道，在业务处理过程中简单方便很多。

#### 低耦合度

MVVM模式中，数据是独立于UI的。

数据和业务逻辑处于一个独立的ViewModel中，ViewModel只需要关注数据和业务逻辑，不需要和UI或者控件打交道。也不持有UI控件的引用。它非常完美的解耦了View层和ViewModel，解决了上面我们所说的MVP的痛点。

#### 更新UI

在MVVM中，数据发生变化后，我们在工作线程直接修改（在数据是线程安全的情况下）ViewModel的数据即可，不用再考虑要切到主线程更新UI了，这些事情相关框架都帮我们做了。

#### 可复用性

一个ViewModel可以复用到多个View中。同样的一份数据，可以提供给不同的UI去做展示。对于版本迭代中频繁的UI改动，更新或新增一套View即可。如果想在UI上做A/B Testing，那MVVM是你不二选择。

#### 单元测试

不管是UI的单元测试还是业务逻辑的单元测试，都是低耦合的。在MVVM中数据是直接绑定到UI控件上的（部分数据是可以直接反映出UI上的内容），那么我们就可以直接通过修改绑定的数据源来间接做一些Android UI上的测试。



### 模型联系

#### View

View层做的就是和UI相关的工作，我们只在XML、Activity和Fragment写View层的代码，View层不做和业务相关的事，也就是我们在Activity不写业务逻辑和业务数据相关的代码，更新UI通过数据绑定实现，尽量在ViewModel里面做（更新绑定的数据源即可），Activity要做的事就是初始化一些控件（如控件的颜色，添加RecyclerView的分割线），View层可以提供更新UI的接口（但是我们更倾向所有的UI元素都是通过数据来驱动更改UI），View层可以处理事件（但是我们更希望UI事件通过Command来绑定）。**简单地说：View层不做任何业务逻辑、不涉及操作数据、不处理数据，UI和数据严格的分开。**

#### ViewModel

ViewModel就是专注于业务的逻辑处理，做的事情也都只是对数据的操作，这些数据绑定在相应的控件上会自动去更改UI。同时DataBinding框架已经支持双向绑定，让我们可以通过双向绑定获取View层反馈给ViewModel层的数据，并对这些数据上进行操作。

关于对UI控件事件的处理，我们也希望能把这些事件处理绑定到控件上，并把这些事件的处理统一化，为此我们通过BindingAdapter对一些常用的事件做了封装，把一个个事件封装成一个个Command，对于每个事件我们用一个ReplyCommand去处理就行了，ReplyCommand会把你可能需要的数据带给你，这使得我们在ViewModel层处理事件的时候只需要关心处理数据就行了。

#### Model

Model层最大的特点是被赋予了数据获取的职责，与我们平常Model层只定义实体对象的行为截然不同。实例中，数据的获取、存储、数据状态变化都是Model层的任务。Model包括实体模型（Bean）、Retrofit的Service ，获取网络数据接口，本地存储（增删改查）接口，数据变化监听等。Model提供数据获取接口供ViewModel调用，经数据转换和操作并最终映射绑定到View层某个UI元素的属性上。



### 代码实现

//todo

### 优缺点





# 软件周期

常见的软件周期：瀑布模型、快速原型、迭代开发、螺旋模型

## 瀑布模型

瀑布模型现在看来是比较老旧的方式了，一条龙下来的模型，是典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。

瀑布模型强调文档的作用，并要求每个阶段都要仔细验证。但是，这种模型的线性过程太理想化，已不再适合现代的软件开发模式，几乎被业界抛弃，其主要问题在于：

- 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；
- 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；
- 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。

## 快速原型

 [快速原型模型](https://baike.baidu.com/item/快速原型模型)的第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品。
 快速原型的关键在于尽可能快速地建造出软件原型，一旦确定了客户的真正需求，所建造的原型将被丢弃。因此，[原型系统](https://baike.baidu.com/item/原型系统)的内部结构并不重要，重要的是必须迅速建立原型，随之迅速修改原型，以反映客户的需求。



## 迭代开发

每次只设计和实现这个产品的一部分, 逐步逐步完成的方法叫迭代开发, 每次设计和实现一个阶段叫做一个迭代，第一个增量往往是实现基本需求的核心产品。核心产品交付用户使用后，经过评价形成下一个增量的开发计划，它包括对核心产品的修改和一些新功能的发布。这个过程在每个增量发布后不断重复，直到产生最终的完善产品。
 迭代开发模型也存在以下缺陷：
 （1） 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。
 （2） 在开发过程中，需求的变化是不可避免的增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性



各自特点：
 瀑布模型 文档驱动 系统可能不满足客户的需求
 快速原型模型 关注满足客户需求 可能导致系统设计差、效率低，难于维护
 迭代模型 开发早期反馈及时，易于维护 。但是需要开放式体系结构，易扩展。可能会导致效率低下
 螺旋模型风险驱动 风险分析人员需要有经验且经过充分训练



