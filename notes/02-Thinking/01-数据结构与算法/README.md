# 数据结构与算法

Talk is cheap，Show me the code！！！



### 数据结构 VS 算法

- 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。
- 从狭义上讲，指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。
- 数据结构和算法是相辅相成的。 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 

- 10个常用数据结构： 
  - 数组、 链表、 栈、 队列、 散列表、 二叉树、 堆、 跳表、 图、 Trie树； 

- 10个常用算法： 
  - 递归、 排序、 二分查找、 搜索、 哈希算法、 贪心算法、 分治算法、 回溯算法、 动态规划、 字符串匹配算法。

- 学习技巧

  - 知识需要沉淀，不要想试图一下子掌握所有
  - 边学边练，适度刷题
  - 多问、多思考、多互动




### 复杂度分析

- 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！
- 时间、空间复杂度分析方法。又叫：事后统计法
- 局限性：测试结果非常依赖测试环境，测试结果受数据规模的影响很大

#### 大O复杂度表示法

- 代码的执行时间T(n)与每行代码的执行次数成正比：**T(n)=O(f(n))**
  - T(n)我们已经讲过了，它表示代码执行的时间
  - n表示数据规模的大小
  - f(n)表示每行代码执行的次数总和
  - O表示代码的执行时间T(n)与f(n)表达式成正比
- 公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，
- 例如：T(n) = O(2n+2)=O(n)；T(n) = O(2n^2+2n+3)=O(n^2)

#### 时间复杂度分析

- 大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
- 分析方法
  - 只关注循环执行次数最多的一段代码
  - 加法法则：总复杂度等于量级最大的那段代码的复杂度，
    - 如果T1(n)=O(f(n))， T2(n)=O(g(n))；
    - 那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))
    - 两个数据规模：T1(m) + T2(n) = O(f(m) + g(n))。
  - 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
    - 如果T1(n)=O(f(n))， T2(n)=O(g(n))
    - 那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))

#### 几种常见时间复杂度(按数量级递增)

- 常量阶：O(1)
  
  - 只要代码的执行时间不随n的增大而增长，都记作O(1)。
  
- 对数阶：O(logn)
  
  ```kotlin
  fun logNText(n: Int) {
      var x = 0
      var i = 1
      while (i <= n) {
          i *= 2
          x++
      }
      println("n:$n") //100
      println("i:$i") //128
      println("x:$x") //7
  }
  ```
  
  - 变量i的值从1开始取，每循环一次就乘以2。当i大于n时假设循环了x次，程序结束。
  - 类比等比数列：2^0、2^1、2^2、2^3......2^x=n，只要知道x值是多少，就知道循环执行的次数了。
  - 通过 **$2^x$=n** 求解 x 得到：**x= $log_2^n$**  
  - 对数之间是可以通过换底公式互相转换
  -  $log_3^n$  =  $\displaystyle \frac{lg^n }{lg^3 }$   =   $\displaystyle \frac{lg^n }{lg^2 }$  ×   $\displaystyle \frac{lg^2 }{lg^3 }$    =   $ log_3^2$  ×  $log_2^n$
  - 所以 O($log_3^n$) = O(C ×$log_2^n$)，其中 C=$log_3^2$ 是一个常量，可以忽略
  - 所以在对数阶时间复杂度的表示方法里，我们可以忽略对数的底，统一表示为O(logn)
  
- 线性阶：O(n)、O(m+n)、 O(m*n)
  - 一个数据规模
  - 两个数据规模先后
  - 两个数据规模嵌套
  
- 线性对数阶：O(nlogn)
  - 如果一段代码的时间复杂度是O(logn)，再将它循环执行n遍，时间复杂度就是O(nlogn)了
  - 归并排序、快速排序的时间复杂度都是O(nlogn)
  
- 次方阶：O(n^2)、O(n^3).... O(n^k)
  
  - 多层嵌套
  
- 指数阶：O(z^n)

- 阶乘阶：O(n!)

- 空间复杂度分析
  - 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity）， 表示算法的存储空间与数据规模之间的增长关系
  - 常见的空间复杂度就是O(1)、 O(n)、 O(n2 )，像O(logn)、 O(nlogn)这样的对数阶复杂度平时都用不到。









最好情况时间复杂度（best case time complexity）

最坏情况时间复杂度（worst case time complexity）

平均情况时间复杂度（average case time complexity）

均摊时间复杂度（amortized time complexity）







- [链表](https://github.com/jaydroid1024/awesome-dev-note/blob/main/notes/02-Thinking/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01-%E9%93%BE%E8%A1%A8.md)
  - 链表相关在线题库
    - [LeetCode ｜ linked-list](https://leetcode-cn.com/problemset/all/?topicSlugs=linked-list)
    - [牛客网](https://www.nowcoder.com/ta/job-code-total) 
  - 链表相关解题方法
    - 深入理解链表数据结构
    - 双指针法
    - 交换节点
    - 删除节点
    - 插入节点
  - 链表相关题目
    - 反转链表
    - 判断链表中是否有环
    - 合并有序链表
    - 链表中的节点每k个一组翻转
    - 链表中环的入口节点
    - 删除链表的倒数第n个节点
    - 两个链表生成相加链表
    - 两个链表的第一个公共结点
    - 合并k个已排序的链表
    - 链表排序
    - 判断一个链表是否为回文结构
    - 链表内指定区间反转
    - 删除有序链表中重复出现的元素
    - 链表的奇偶重排
    - 重排链表
    - 删除有序链表中重复的元素
    - 环形链表的约瑟夫问题





## 参考

[牛客网-字节跳动-企业题库](https://www.nowcoder.com/company/home/code/665?codeType=1)

[LeetCode | 剑指offer](https://leetcode-cn.com/problemset/lcof/) 

