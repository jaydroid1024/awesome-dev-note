# 大厂常考算法题合集



## 001-Android 字节跳动算法题：给定ViewGroup打印其内所有的View

### 解题思路

[参考题解](https://cloud.tencent.com/developer/article/1513280)

在 Android 下，UI 的布局结构，对标到数据结构中，本质就是一个由 View 和 ViewGroup 组成的多叉树结构。其中 View 只能作为叶子节点，而 ViewGroup 是可以存在子节点的。

遍历整个ViewTree，还需要用到两个 ViewGroup 的方法。

- `getChildCount()`：获取其子 View 的个数。
- `getChildAt(int)`：获取对应索引的子 View。

对于 View，无需过多处理，直接打印输出即可。而 ViewGroup，除了打印自身的这个节点之外，还需要打印其子节点。

### 解题实现

#### 2.1 递归实现

**当一个大问题，可以被拆分成多个小问题，并且分解后的小问题，和大问题相比，只是数据规模不同，求解思路完全一致的问题，非常适合递归来实现。**

递归确实可以很清晰的实现功能，但是它有一个致命的问题，当递归深度过深的时候，会爆栈。反应在程序上，就是会抛出 `StackOverflowError`这个异常。

```java
public int traverseViewGroup(View view) {
    int viewCount = 0;
    if (null == view) {
        return 0;
    }
    if (view instanceof ViewGroup) {
        //遍历ViewGroup,是子view加1，是ViewGroup递归调用
        for (int i = 0; i < ((ViewGroup) view).getChildCount(); i++) {
            View child = ((ViewGroup) view).getChildAt(i);
            if (child instanceof ViewGroup) {
                viewCount += traverseViewGroup(((ViewGroup) view).getChildAt(i));
            } else {
                viewCount++;
            }
        }
    } else {
        viewCount++;
    }
    return viewCount;
 }
```

#### 2.2 广度优先实现

广度优先的过程，就是对每一层节点依次访问，访问完了再进入下一层。就是**按树的深度，一层层的遍历访问**。

**广度优先非常适合用先入先出的队列来实现**，每次子 View 都入队尾，而从对头取新的 View 进行处理。

```kotlin
fun breadthFirst(root :View){
    val viewDeque = LinkedList<View>()
    var view = root
    viewDeque.push(view)
    while (!viewDeque.isEmpty()){
        view = viewDeque.poll()
        printView(view)
        if(view is ViewGroup){
            for(childIndex in 0 until view.childCount){
                val childView = view.getChildAt(childIndex)
                viewDeque.addLast(childView)
            }
        }
    }
}
```

#### 2.3 深度优先实现

深度优先的过程，就是对每个可能的分支路径，深度到叶子节点，并且每个节点只访问一次。

在实现上，**深度优先非常适合用先入后出的栈来实现**。逻辑不复杂，直接上执行时，栈的数据变换。

```kotlin
fun depthFirst(root :View){
    val viewDeque = LinkedList<View>()
    var view = root
    viewDeque.push(view)
    while (!viewDeque.isEmpty()){
        view = viewDeque.pop()
        printView(view)
        if(view is ViewGroup){
            for(childIndex in 0 until view.childCount){
                val childView = view.getChildAt(childIndex)
                viewDeque.push(childView)
            }
        }
    }
}
```

依然利用 `LinkedList` 来当栈使用，利用 `push()` 和 `pop()` 实现栈的逻辑。

这道题，还有一些变种，例如统计 ViewGroup 子 View 的数量、分层打印 ViewTree、查找 ID 为 Xxx 的 View 等，



