# 实战设计模式-创建型-单例模式



- 为什么要使用单例
- 经典实现方式有哪些
- Effective Java 作者为什么推荐枚举单例
- 单例存在哪些问题
- 单例与静态类的区别
- 有何替代的解决方案
- 饿汉式单例模式为什么是线程安全的呢？指令重排不会有影响吗？
- 如何理解单例模式中的唯一性？
- 如何实现线程唯一的单例？
- 如何实现集群环境下的单例？



## 单例模式概述

### 什么是单例模式

- 单例设计模式（Singleton Design Pattern）：一个类只允许创建一个实例，那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式

### 为什么要使用单例

- 单例模式同时解决了两个问题
- 保证一个类只有一个实例
- 为该实例提供一个全局访问节点

### 如何理解单例模式中的唯一性

- 单例模式创建的对象是进程唯一的。

- 我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Android 设备下的 apk文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。
- 当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。
- 进程之间是不共享地址空间的,单例类在老进程中存在且只能存在一个对象，在另一个进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。

### 如何实现线程唯一的单例

我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。

实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal底层实现原理也是基于下面代码中所示的 HashMap

### 如何实现集群环境下的单例

- 集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。

- 我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。

- 为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁

### 如何实现一个多例模式

- 多例指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象
- 对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。
- 通常通过map 实现多例模式，例如：ConcurrentHashMap、HashMap
- 这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象
- 实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。

### 单例存在哪些问题

- 单例对 OOP 特性的支持不友好
  - 单例模式违背了基于接口而非实现的设计原则，也就违背了广义上理解的OOP 的抽象特性。
  - 一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。
- 单例会隐藏类之间的依赖关系
  - 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。
- 单例对代码的扩展性不友好
  - 单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。
- 单例对代码的可测试性不友好
  - 如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换
  - 单例类持有成员变量实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。
- 单例不支持有参数的构造函数
  - 第一种解决思路是： 先调用 init() 函数传递参数，创建实例，然后才能调用 getInstance() 方法，否则代码会抛出异常。
  - 第二种解决思路是：将参数放到 getIntance() 方法中。
  - 第三种解决思路是：将参数放到另外一个全局变量中。

### 如何实现一个单例

- 要实现一个单例，我们需要关注的点无外乎下面几个：
- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
- 考虑对象创建时的线程安全问题
- 考虑是否支持延迟加载
- 考虑 getInstance() 性能是否高（是否加锁）
- 考虑防破坏的情况

### 如何确保单例的唯一性不被破坏

- 防止反射
- 防止序列化
- 防止 clone

### 类锁与对象锁的区别

- java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，
- 对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。
- 类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。
- 对象锁修饰成员方法和普通代码块（this,lockObj），类锁修饰静态方法和静态代码块(xx.class, lockStaticObj)。
- 一个类的对象锁和另一个类的对象锁是没有关联的，当一个线程获得A类的对象锁时，它同时也可以获得B类的对象锁。

### synchronized如何保证可见性的

- 根据Java内存模型，synchronized的语义不仅仅是在同一个信号上的互乐(mutex),也包含线程和主存之间数据交互
  同步,它确保在多处理器、多线程下对内存能有可预见的一致性视图。
- 获取或释放锁会触发一次内存屏障(memory barrier) 强迫线程本地存和主存同步。
- 当一个线程退出一个synchronized block,触发一次写屏障(write barrier )
- 在释放锁前必须把所有在这个同步块里修改过的变量值刷新到主存
- 同样，进入一个synchronized block 触发一次读屏障

### 什么是指令重排序

- [详细解读参考](https://blog.csdn.net/yjp198713/article/details/78839698)

- java中的指令重排序是：重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。

  重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。

- 重排序数据依赖性：写后读(a = 1;b = a)，写后写(a = 1;a = 2)，读后写(a = b;b = 1)

- 编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

- 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑

- [测试指令重排序在高并发下的问题的例子]()

### volatile 是干什么的

- 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 禁止进行指令重排序。

### 对象的创建过程

- 对象的创建过程(Object o=new Object())，并不是一步完成的，而是分为多步：

- 1、申请内存空间，并且默认初始化（赋0值，半初始化）

- 2、调用构造方法，进行初始化，赋值等

- 3、返回地址给，使 o 指向分配的地址空间（执行完 3 时 o 就不为null）

- ```
  //对应的字节码为：
  0: new           #2                  // class java/lang/Object
  3: dup
  4: invokespecial #1                  // Method java/lang/Object."<init>":()V
  7: astore_1
  8: return
  ```

### JVM是如何保证类初始化过程中线程安全的

- 由于java语言是多线程的，多个线程可能在同一时间尝试去初始化同一个类或接口因此在java中初始化一个类或者接口时，需要做细致的同步处理。
- Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。
- JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了

### 触发 Java 类初始化的条件有哪些

- 类的详细加载过程：[Java | 12.4.2.详细的初始化程序](https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4.2)

- 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用，卸载7个阶段。其中验证、准备、解析三个部分统称为连接。

- 类的加载成功后，即静态成员都被加载后，是不会再加载第二次的。只有非静态成员，如非静态成员变量、非静态代码块、非静态方法(不调用不加载)、构造方法都会被多次实例化的时候多次加载。

- 对于初始化阶段，虚拟机规范则是严格规定了下面的几种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)

- 使用 new 关键字实例化对象

- 读取或设置一个类的静态字段，对应的字节码指令：getstatic 和 putstatic 

  - 注意：当访问类的 static final 修饰的变量时，不会触发类的初始化
  - 注意：静态属性有final修饰时也有情况会被加载,public static final int a=getNum();这样也会被加载。getNum()是静态方法，并且不管这个静态方法是子类的还是父类的
  - 常量在编译阶段会存入调用类的常量池中，常量是一种特殊的变量，编译器会把他们当作值(value)而不是域(field)来对待；如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。

- 调用类的静态方法，字节码指令：invokestatic 

  - 注意：调用静态且final的成员方法时，会触发类的初始化！一定要和静态且final修饰的变量区分开！！

- 对类进行反射调用的时候

  - 注意：通过类名.class得到Class文件对象并不会触发类的加载

- 当初始化类的父类还没有进行过初始化，则需要先触发其父类的初始化。

  - 接口的加载过程与类的加载过程稍有不同。接口中不能使用static{}块。
  - 当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用父类接口中定义的常量）才会初始化
  - 注意：通过子类调用父类的静态成员时，只会初始化父类而不会初始化子类。 因为没有调用子类的相关静态成员，这也叫做能不加载不加载原则。
  - 注意：调用静态成员时，会加载静态成员真正所在的类及其父类。 这也好理解，因为本类的父类没有加载就会先去加载父类。

- 虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。

  - 直接使用`java.exe`命令来运行某个主类，本质上就是调用main方法，所以必须要有main方法才行。

- 总结一下就是以下几种情况特殊外，其它能想到的情况都是会初始化类的

- ```java
  //静态常量 todo 这种方式不会触发类的初始化
  public static final int static_final = 2048;
  //通过类名.class得到Class文件对象  todo 这种方式不会触发类的初始化
  Class<InvokeTime> invokeTimeClass = InvokeTime.class;
  //通过子类调用父类静态成员  todo 这种方式不会触发子类的初始化
  System.out.println(InvokeTime.static_value_parent);
  //静态变量 todo 当一个接口在初始化时，并不要求其父接口全部都完成了初始化
  System.out.println(InvokeTimeInterface.static_value);
  ```



## Java 单例模式的经典实现方式



### 饿汉式

```java
/**
 * 饿汉式单例类
 * 饿汉式是如何保证并发安全性
 * 因为静态变量是在类初始化的时候赋值，而类初始化是线程安全(JVM保证)的，不存在多个线程初始化多次的问题，
 * 因此是线程安全的。
 */
public final class Eagerly {

    /**
     * 提供一个静态实例
     */
    private static final Eagerly INSTANCE = new Eagerly();

    /**
     * 私有化构造器
     */
    private Eagerly() {
    }

    /**
     * 提供一个公开的供全局访问的静态方法并返回实例
     * @return 单例对象的实例
     */
    public static Eagerly getInstance() {
        return INSTANCE;
    }
}
```



### 懒汉式

懒汉式相对于饿汉式的优势是支持延迟加载。

```java
/**
 * 懒汉式单例
 * 懒汉式相对于饿汉式的优势是支持延迟加载
 * 懒汉式单例是如何保证线程安全的
 * synchronized 修饰在静态方法上属于类锁作用域，类锁可以保证高并发的安全性，但是降低了并发效率
 */
public final class Lazy {
    
    /**
     * 提供一个静态实例的引用，延迟初始化
     */
    private static Lazy instance;

    /**
     * 私有化构造器且防止反射实例化
     */
    private Lazy() {
        // 防止通过反射实例化
        if (instance == null) {
            instance = this;
        } else {
            throw new IllegalStateException("Already initialized.");
        }
    }

    /**
     * 提供一个公开的供全局访问的静态方法用于返回实例
     * 该实例在第一次调用该方法之前，不会被创建。
     * @return 单例对象的实例
     */
    public static synchronized Lazy getInstance() {
        if (instance == null) {
            instance = new Lazy();
        }
        return instance;
    }
}
```



### DCL(Double check locking)

```java
/**
 * DCL单例(Double check locking)
 * 双重检查锁定被破坏声明
 * http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html
 * Broken under Java 1.4
 *
 什么是指令重排序
 指令进行重排序的目的是为了提高程序的运行效率
 单线程内指令重排序为什么不会有问题
 根据java语言规范，所有线程在执行java程序时必须要遵守 intra-thread semantics（线程内语义）。
 线程内语义保证重排序不会改变单线程内的程序执行结果。

 volatile有两个特性：可见性和有序性
 什么是可见性，即线程A修改变量x，那么对于线程B应该立即可以获取到信息x被修改，并重新读取
 什么是有序性，即禁止许指令重排序
 禁止重排序是怎么做到的？
 一是语义层次，二是内存屏障。内存屏障分为读屏障(loadload)，写屏障(storestore)，读写屏障(loadstore或storeload)；如load,loadload,load，
 在进行新的读操时，加入读屏障，保证上一次的读操作完成再执行新的读操作而不会越过屏障去执行新操作。
 
 DCL单例模式为什么需要通过 volatile 禁止重排序
 对象的创建过程(Object o=new Object())，并不是一步完成的，而是分为多步：
 1、申请内存空间，并且默认初始化（赋0值，半初始化）
 2、调用构造方法，进行初始化，赋值等
 3、返回地址给，使 o 指向分配的地址空间（执行完 3 时 o 就不为null）
 对应的字节码为：
 0: new           #2                  // class java/lang/Object
 3: dup
 4: invokespecial #1                  // Method java/lang/Object."<init>":()V
 7: astore_1
 8: return
 在高并发的情况下，DLC双重检验不能保证由于指令重排（1-3-2）导致的线程获取到未完全初始化对象的问题，
 所以需要利用volatile禁止重排的特性来保证单例的线程安全。
 *
 */
public final class DoubleCheckLock {

    /**
     * 提供一个静态实例的引用，延迟初始化
     * volatile:防止指令重排序
     */
    private static volatile DoubleCheckLock instance;

    //防止反射的标志位
    private static boolean flag = true;

    /**
     * 私有构造函数以防止客户端实例化。
     */
    private DoubleCheckLock() {
        // 防止通过反射实例化
        if (flag) {
            flag = false;
        } else {
            throw new IllegalStateException("Already initialized.");
        }
    }

    /**
     * 供全局访问的静态方法
     * 只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。
     * 所以，这种实现方式解决了懒汉式并发度低的问题。
     * @return 单例对象的实例
     */
    public static DoubleCheckLock getInstance() {
        // 局部变量将性能提高了 25% Joshua Bloch “Effective Java, Second Edition”，第 3 页。 283-284
        DoubleCheckLock result = instance;
        // 检查单例实例是否已初始化。如果它被初始化，那么我们可以返回实例。
        if (result == null) {
            // 它没有初始化，但我们不能确定，因为其他线程可能同时初始化了它。
            // 所以为了以防万一，这里需要添加一把互斥锁来保证只有一个线程去实例化实例对象。
            synchronized (DoubleCheckLock.class) {
                // 再次将实例分配给局部变量以检查它是否被其他线程初始化，而当前线程被阻止进入锁定区域。
                // 如果它被初始化，当前线程也能感知他的存在了。
                result = instance;
                if (result == null) {
                    // 该实例仍未初始化，因此我们可以安全地（没有其他线程可以进入该区域）创建一个实例并将其赋值给我们的单例引用。
                    instance = result = new DoubleCheckLock();
                }
            }
        }
        return result;
    }
}
```



### 静态内部类

```java
/**
 * 静态内部类单例
 * Initialize-on-demand-holder 惯用语是在 Java 中创建惰性初始化单例对象的一种安全方式。
 * 该技术尽可能地惰性并且适用于所有已知的 Java 版本。
 * 它利用关于类初始化的语言级保证，因此将在所有符合 Java 的编译器和虚拟机中都能正常工作。
 * 类加载器加载的时间不早于调用 getInstance() 的那一刻。
 * 因此，该解决方案是线程安全的，不需要其它特殊的保障（例如 volatile 或 synchronized）。
 */
public final class InitializingOnDemandHolder {

    /**
     * 私有化构造
     */
    private InitializingOnDemandHolder() {
    }

    /**
     * 提供一个公开的供全局访问的静态方法并返回实例
     * @return 单例对象的实例
     */
    public static InitializingOnDemandHolder getInstance() {
        return SingletonHolder.INSTANCE;
    }

    /**
     * 提供延迟加载的 Singleton 实例。
     * SingletonHolder 是一个静态内部类，当外部类 InitializingOnDemandHolder 被加载的时候，
     * 并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，
     * SingletonHolder 才会被加载，这个时候才会创建 INSTANCE。
     * INSTANCE 的唯一性和创建过程的线程安全性，都由JVM 来保证。
     * 所以，这种实现方法既保证了线程安全，又能做到延迟加载
     */
    private static class SingletonHolder {
        private static final InitializingOnDemandHolder INSTANCE = new InitializingOnDemandHolder();
    }
}
```



### 枚举

```java
/**
 * 枚举单例
 * 枚举是如何保证并发安全的
 * INSTANCE 反编译后是 public static final 类型的，因为static类型的属性会在类被加载之后被初始化，
 * 当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。
 * 所以，创建一个enum类型是线程安全的。
 */
public enum Enum {
    INSTANCE
}
```



### CAS(AtomicReference)

```java
/**
 * CAS(AtomicReference)
 * - java并发库提供了了很多原⼦子类来支持并发访问的数据安全性； AtomicInteger 、 AtomicBoolean 、 AtomicLong 、 AtomicReference 。
 * - AtomicReference 可以封装引用的一个实例，支持并发访问如上的单例方式就是使用了这样的一个特点。
 * - 使⽤用CAS的好处就是不不需要使用传统的加锁方式保证线程安全，而是依赖于CAS的忙等算法，依赖于底层硬件的实现，来保证线程安全。相对于其他锁的实现没有线程的切换和阻塞也就没有了额外的开销，并且可以支持较大的并发性。
 * - 当然CAS也有一个缺点就是忙等，如果一直没有获取到将会处于死循环中。
 * @author jaydroid
 * @version 1.0
 * @date 2021/8/23
 */
public final class CAS {

    private static final AtomicReference<CAS> INSTANCE = new AtomicReference<CAS>();

    private static CAS instance;

    private CAS() {
    }

    public static final CAS getInstance() {
        for (; ; ) {
            CAS instance = INSTANCE.get();
            if (null != instance) return instance;
            INSTANCE.compareAndSet(null, new CAS());
            return INSTANCE.get();
        }
    }

}
```



## Kotlin 单例模式的经典实现方式



### Object 

```kotlin
/**
 * object单例
 * object单例通过反编译为java代码可以看到是和Java 枚举一样都是饿汉式单例
 * 参见 Java 饿汉式
 */
object KotlinObject {

}

/*
反编译为 Java 代码后
public final class KotlinObject {

   @NotNull
   public static final KotlinObject INSTANCE;

   private KotlinObject() {
   }

   static {
      KotlinObject var0 = new KotlinObject();
      INSTANCE = var0;
      instance = var0;
   }
}
 */
```



### Lazy

```kotlin
/**
 * KotlinLazy
 */
class KotlinLazy {

    companion object {
        val instance: KotlinLazy by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {
            KotlinLazy()
        }
    }
}

/*
反编译为 Java 代码后
public final class KotlinLazy {
   @NotNull
   private static final Lazy instance$delegate;
   @NotNull
   public static final KotlinLazy.Companion Companion = new KotlinLazy.Companion((DefaultConstructorMarker)null);

   static {
      instance$delegate = LazyKt.lazy(LazyThreadSafetyMode.SYNCHRONIZED, (Function0)null.INSTANCE);
   }
   public static final class Companion {
      @NotNull
      public final KotlinLazy getInstance() {
         Lazy var1 = KotlinLazy.instance$delegate;
         KotlinLazy.Companion var2 = KotlinLazy.Companion;
         Object var3 = null;
         boolean var4 = false;
         return (KotlinLazy)var1.getValue();
      }

      private Companion() {
      }

      // $FF: synthetic method
      public Companion(DefaultConstructorMarker $constructor_marker) {
         this();
      }
   }
}
 */
```



## 谁在用单例模式

| 谁在使用                                                     | 使用方式              | 手写实现   |
| ------------------------------------------------------------ | --------------------- | ---------- |
| [Java \| Runtime](http://www.docjar.com/html/api/java/lang/Runtime.java.html) | 饿汉式                | [Github]() |
| [Java \| Desktop](http://www.docjar.com/html/api/java/awt/Desktop.java.html) | 懒汉式+Map容器缓存    |            |
| [Android \| ConnectivityThread](https://cs.android.com/android/platform/superproject/+/master:packages/modules/Connectivity/framework/src/android/net/ConnectivityThread.java;l=29;bpv=1;bpt=1?q=ConnectivityThread) | 静态内部类            |            |
| [Android \| Singleton](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/util/Singleton.java?q=android.util.Singleton.java) | 懒汉式                |            |
| [EventBus](https://github.com/greenrobot/EventBus/blob/master/EventBus/src/org/greenrobot/eventbus/EventBus.java) | DCL+volatile+局部变量 |            |
| [Jetpack \| startup](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:startup/startup-runtime/src/main/java/androidx/startup/AppInitializer.java) | DCL+volatile          |            |
| [Jetpack \| Room](https://github.com/android/architecture-components-samples/blob/master/BasicSample/app/src/main/java/com/example/android/persistence/db/AppDatabase.java) | DCL                   |            |
| [Jetpack \| WorkManager](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:work/work-runtime/src/main/java/androidx/work/WorkManager.java;l=149?q=androidx.work.WorkManager) | 懒汉式                |            |
| [ARouter](https://github.com/alibaba/ARouter/blob/develop/arouter-api/src/main/java/com/alibaba/android/arouter/launcher/ARouter.java) | DCL+volatile          |            |



## 参考

- [极客时间| 设计模式之美](https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D)
- [慕课网 | java设计模式精讲 Debug 方式+内存分析](https://coding.imooc.com/class/270.html?mc_marking=6eab7b8c9bc28db4f23571353f1a9fe5&mc_channel=banner)
- [在线书籍 | 深入设计模式](https://refactoringguru.cn/design-patterns)
- [bugstack虫洞栈 | 实战设计模式](https://bugstack.cn/itstack/itstack-demo-design.html)
- [菜鸟教程 | 设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [Github | java-design-patterns](https://github.com/iluwatar/java-design-patterns)
- [Github | Design-Patterns-In-Kotlin](https://github.com/dbacinski/Design-Patterns-In-Kotlin)

