# 实战设计模式-行为型-观察者模式

## 概述

### 定义

行为型|Behavioural | 观察者模式| Observer Pattern

观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）

**观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。**

不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。

| 被观察者                                                     | 绑定                                                         | 观察者                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 被观察者（Observable）                                       | addObserver                                                  | 观察者（Observers）                                          |
| 发布者 （publisher）                                         | addSubscriber/@Subscribe                                     | 订阅者（subscribers）                                        |
| 事件发射器（EventEmitter）                                   | addListener                                                  | 事件监听者（EventListeners）                                 |
| 事件会在发布者自身状态改变或执行特定行为后发生。<br /> 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。<br />一般实现：<br />用于存储订阅者对象引用的容器； <br />用于添加或删除该容器中订阅者的公有方法。<br /> | 当新事件发生时，<br />发送者会遍历订阅列表<br />并调用每个订阅者对象的更新方法。 <br />该方法是在订阅者接口中声明的。 | 所有订阅者都必须实现同样的接口， <br />该接口仅包含一个 `update`更新方法。 <br />该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。<br />发布者仅通过该接口与订阅者交互。<br />接口中必须声明通知方法及其参数， 这<br />样发布者在发出通知时还能传递一些上下文数据。 |



行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。

生活中对观察者模式的运用非常多，例如：关注(抖音主播)、订阅(周报) 、降价通知等操作一般都是基于观察者。

观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子。

不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。

### 观察者模式的实现方式

- 同步阻塞是最经典的实现方式，主要是为了代码解耦；观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。

- 异步非阻塞除了能实现代码解耦之外，还能提高代码的执行效率；实现方式是启动一个新的线程来执行观察者的回调函数。

- 进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。

### 观察者模式的应用场景

- 关联行为场景，用于建立一套触发机制，事件多级触发场景;
- 跨系统的消息交换场景，如消息队列、事件总线的处理机制。
- 当应用中的一些对象必须观察其他对象时**，** 可使用该模式**。** 但仅能在有限时间内或特定情况下使用**。**
- 当一个对象状态的改变需要改变其他对象**，** 或实际对象是事先未知的或动态变化的时**，** 可使用观察者模式**。**

### 发布-订阅模型和生产-消费模型的区别和联系

发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现。
生产-消费模型，是多对多的关系，一般以异步的方式实现
两者都可以达到解耦的作用且在流程上都有先后关系。





## 经典实现



## 谁在用



## 参考

- [极客时间| 设计模式之美](https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D)
- [慕课网 | java设计模式精讲 Debug 方式+内存分析](https://coding.imooc.com/class/270.html?mc_marking=6eab7b8c9bc28db4f23571353f1a9fe5&mc_channel=banner)
- [在线书籍 | 深入设计模式](https://refactoringguru.cn/design-patterns)
- [bugstack虫洞栈 | 实战设计模式](https://bugstack.cn/itstack/itstack-demo-design.html)
- [菜鸟教程 | 设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [Github | java-design-patterns](https://github.com/iluwatar/java-design-patterns)
- [Github | Design-Patterns-In-Kotlin](https://github.com/dbacinski/Design-Patterns-In-Kotlin)
- [Github | flutter-design-patterns](https://github.com/mkobuolys/flutter-design-patterns)

