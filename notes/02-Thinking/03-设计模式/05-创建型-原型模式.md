# 实战设计模式-创建型-原型模式

## 概述

### 定义

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大(大部分字段都相同)，在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。原型模式有两种实现方法，深拷贝和浅拷贝。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式（Prototype）。

### 何为“对象的创建成本比较大”？

创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。

例如：对大量数据的哈希表的创建操作

### 原型模式的实现方式：深拷贝和浅拷贝

浅拷贝和深拷贝的区别在于：浅拷贝只会复制索引，不会复制数据本身，相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象跟原始对象共享数据，而深拷贝得到的是一份完完全全独立的对象。

在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象的内存地址，不会递归地拷贝引用对象本身。如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险。此时就需要采用深拷贝或者结合浅拷贝一起来实现拷贝过程了。

**如何实现深拷贝**

第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。

第二种方法：先将对象序列化，然后再反序列化成新的对象。

不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。我们可以先采用浅拷贝的方式创建一个对象。对于需要部分更新的对象，我们再使用深度拷贝的方式创建一份新的对象，替换老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证新老对象数据的隔离。

## 经典实现





## 谁在用建造者模式

**识别方法：** 原型可以简单地通过 `clone`或 `copy`等方法来识别。

#### Java| Cloneable

Java 的 `Cloneable` （可克隆） 接口就是开箱即用的原型模式。任何类都可通过实现该接口来实现可被克隆的性质。

[`java.lang.Object#clone()`](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone--) （类必须实现 [`java.lang.Cloneable`](http://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html) 接口）

[stackoverflow | Why is Object.clone() native in Java?](https://stackoverflow.com/questions/27224577/why-is-object-clone-native-in-java)

#### Android | Cloneable

[管理位图内存](https://developer.android.com/topic/performance/graphics/manage-memory)

[Android: Cloning a drawable in order to make a StateListDrawable with filters](https://stackoverflow.com/questions/7979440/android-cloning-a-drawable-in-order-to-make-a-statelistdrawable-with-filters)

#### Android | Drawable mutate()

```
val drawable = ContextCompat.getDrawable(this, R.mipmap.ic_launcher)
val cloneD: Drawable? = drawable?.constantState?.newDrawable()?.mutate()
```

```java
public void setErrorIconTintList(@Nullable ColorStateList errorIconTintList) {
  Drawable icon = errorIconView.getDrawable();
  if (icon != null) {
    icon = DrawableCompat.wrap(icon).mutate();
    DrawableCompat.setTintList(icon, errorIconTintList);
  }

  if (errorIconView.getDrawable() != icon) {
    errorIconView.setImageDrawable(icon);
  }
}
```

#### Android | Bitmap inBitmap



```
val bitmap = BitmapFactory.decodeResource(resources, R.mipmap.ic_launcher)
val options: BitmapFactory.Options = BitmapFactory.Options()
options.inMutable = true
options.inBitmap = bitmap
val cloneB: Bitmap = BitmapFactory.decodeResource(resources, R.mipmap.ic_launcher, options)
```



创建并返回此对象的副本。 “复制”的确切含义可能取决于对象的类别。 一般意图是，对于任何对象x ，表达式：
       x.clone() != x
将是真的，并且表达式：
       x.clone().getClass() == x.getClass()
会是true ，但这些不是绝对的要求。 虽然通常的情况是：
       x.clone().equals(x)
会是true ，这不是绝对的要求。
按照惯例，返回的对象应该通过调用super.clone来获取。 如果一个类和它的所有超类（除了Object ）都遵守这个约定，那么x.clone().getClass() == x.getClass() 。
按照惯例，这个方法返回的对象应该独立于这个对象（它被克隆）。 为了实现这种独立性，可能需要在返回之前修改super.clone返回的对象的一个或多个字段。 通常，这意味着复制包含被克隆对象的内部“深层结构”的任何可变对象，并将对这些对象的引用替换为对副本的引用。 如果一个类只包含原始字段或对不可变对象的引用，那么通常情况下， super.clone返回的对象中没有字段需要修改。
类Object的方法clone执行特定的克隆操作。 首先，如果该对象的类没有实现接口Cloneable ，则抛出CloneNotSupportedException 。 

 请注意，所有数组都被认为实现了接口Cloneable并且数组类型T[]的clone方法的返回类型是T[] ，其中 T 是任何引用或原始类型。 否则，此方法会创建此对象的类的新实例，并使用此对象的相应字段的内容来初始化其所有字段，就像通过赋值一样； 字段的内容本身不会被克隆。 因此，此方法执行此对象的“浅拷贝”，而不是“深拷贝”操作。
类Object本身不实现接口Cloneable ，因此在类为Object的对象上调用clone方法将导致在运行时抛出异常。

```java
protected Object clone() throws CloneNotSupportedException {
    if (!(this instanceof Cloneable)) {
        throw new CloneNotSupportedException("Class " + getClass().getName() + "doesn't implement Cloneable");
    }
    return internalClone();
}

@FastNative
private native Object internalClone();
```

```c++
/*
 * private Object internalClone()
 *
 * Implements most of Object.clone().
 */
static void Dalvik_java_lang_Object_internalClone(const u4* args,
    JValue* pResult)
{
    Object* thisPtr = (Object*) args[0];
    Object* clone = dvmCloneObject(thisPtr, ALLOC_DONT_TRACK);
    RETURN_PTR(clone);
}
```



## 参考

- [极客时间| 设计模式之美](https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D)
- [慕课网 | java设计模式精讲 Debug 方式+内存分析](https://coding.imooc.com/class/270.html?mc_marking=6eab7b8c9bc28db4f23571353f1a9fe5&mc_channel=banner)
- [在线书籍 | 深入设计模式](https://refactoringguru.cn/design-patterns)
- [bugstack虫洞栈 | 实战设计模式](https://bugstack.cn/itstack/itstack-demo-design.html)
- [菜鸟教程 | 设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [Github | java-design-patterns](https://github.com/iluwatar/java-design-patterns)
- [Github | Design-Patterns-In-Kotlin](https://github.com/dbacinski/Design-Patterns-In-Kotlin)
- [Github | flutter-design-patterns](https://github.com/mkobuolys/flutter-design-patterns)

