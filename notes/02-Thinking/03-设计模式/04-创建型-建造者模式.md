# 实战设计模式-创建型-建造者模式



## 重叠构造器模式 (Telescoping Constructor Pattern)

在 Java 中，不支持构造函数参数的默认值。作为一种解决方法，经常使用一种称为“伸缩构造函数”的技术。一个类有多个构造函数，其中每个构造函数调用层次结构中更具体的构造函数，该构造函数的参数比自身多，为额外的参数提供默认值。下一个构造函数做同样的事情，直到没有剩余。例如下面构建 Person 类的方式就是通过常见的 重叠构造器模式 实现的

```java
public Person(String firstName, String lastName) {
    this(firstName, lastName, "No description available");
}
public Person(String firstName, String lastName, String description) {
    this(firstName, lastName, description, -1);
}
public Person(String firstName, String lastName, String description, int age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.description = description;
    this.age = age;
}
```

#### 重叠构造器带来的问题

随着参数的增加易读性、扩展性、健壮性都变得很差

如果只要只有几个属性，一切似乎都正常。但随着构造参数的增加，问题开始出现。这样的构造函数很难阅读。它们有很多参数——谁知道第六个参数是什么？如果相邻的参数具有相同的类型，你可能意外地调换它们的值，而不会出现编译错误。

此外，在程序使用过程中触发构造对象的场景可能有多种，由于构造函数具有许多参数，其中许多参数设置的默认值为 null。如果不进一步代码追踪，很难看出正在构建对象的哪个变体。当添加新参数时，还必须向重叠链中添加新的构造函数。因此，这种模式不能很好地扩展和维护。

#### 重叠构造器解决方式一：构造器+setter

```java
Person john = new Person();
john.setFirstName("John");
john.setLastName("Droid");
john.setAge(33);
john.setDescription("I am a huge fan on JavaBeans convention!");
System.out.println(john);
```

优点：

- 易于实施和更改
- 易于阅读 - 设置器已命名，您可以立即知道哪些字段被分配了哪些值
- 易于扩展 - 添加越来越多的参数仍然很容易

缺点：

- JavaBeans 是可变的，这意味着它们的状态可以在构造后随时使用 setter 更改。它们的字段不能被声明为 final，这与在构造函数中一次性创建的对象不同。不可变对象有几个优点，特别是线程安全。当对象构造不是原子操作时，可以在尚未完全构造的状态下访问该对象。

#### 重叠构造器解决方式二： 命名静态工厂方法

```java
public static Person createNamedPerson(String firstName, String lastName) {
    return new Person(firstName, lastName);
}

public static Person createUnknownPerson() {
    return new Person("John", "Doe");
}
```

这些是静态方法，它们返回封闭类的实例。与构造函数相比，有一些优点，最显着的是：

- 每个都可以有不同的描述性名称，与构造函数不同，揭示了该方法的意图。
- 不需要每次都返回一个全新的实例 - 可用于实例缓存、池化等。

与 JavaBeans 不同，静态工厂方法在委托给适当的构造函数时可以返回不可变的实例。但是，和构造函数一样，它们的伸缩性不好，不适合有很多不同参数的情况，可以任意组合使用。

#### 重叠构造器解决方式二： 建造者

如果不变性是一个问题，那么如何构造具有许多参数的对象的流行方法是 Builder。

实现步骤：

1. 创建了构建器的一个实例。或者，您可以在构造函数中提供必填字段。
2. 一个接一个地设置字段，这应该是构建的一部分。通常，为了使事情更方便，构建器会返回自身，因此可以实现连调的效果。
3. 完成后，调用 build() 方法并接收构造的对象。构建器调用构造对象的构造函数。它是一次性构造的，因此可以是不可变的。

```java
public static final class Builder {
    private String firstName;
    private String lastName;
    private int age;
    private String description;

    public Builder() {
    }

    public Builder firstName(String val) {
        firstName = val;
        return this;
    }

    public Builder lastName(String val) {
        lastName = val;
        return this;
    }

    public Builder age(int val) {
        age = val;
        return this;
    }

    public Builder description(String val) {
        description = val;
        return this;
    }

    public Person build() {
        return new Person(this);
    }
}

private Person(Builder builder) {
    firstName = builder.firstName;
    lastName = builder.lastName;
    age = builder.age;
    description = builder.description;
}
```

## 建造者模式概述

Builder 模式，中文翻译为建造者模式或者构建者模式，也有人叫它生成器模式。建造者模式用来创建复杂对象，可以通过设置不同的可选参数，定制化地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。

Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。
因为一个复杂的对象有很多大量组成部分，如汽车，有车轮、方向盘、发动机，还有各种小零件等，如何将这些部件装配成一辆汽车， 这个装配过程很漫长，也很复杂，对于这种情况，为了在构建过程中对外部隐藏实现细节，就可以使用 Builder 模式将部件和组装过程分离，使得构建过程和部件都可以自由扩展，两者之间的耦合也降到最低。

### 与工厂模式有何区别？

工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。

建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，定制化地创建不同的对象。

建造者模式重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

网上有一个经典的例子很好地解释了两者的区别。
顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。

对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。

### 使用场景

- 使用建造者模式可避免重叠构造函数 （telescopic constructor）的出现。
- 相同的方法，不同的执行顺序，产生不同的事件结果时。
- 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。
- 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。
- 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。
- 它可以用于包含平面数据（html代码、SQL查询、X.509证书…）的对象，也就是说，无法轻松编辑的数据。
  此类数据不能逐步编辑，必须立即编辑。构造此类对象的最佳方法是使用生成器类。

### 注意事项

为什么我的实现有这么多参数？

类有太多责任可能是一个危险信号。考虑其中一些责任是否可以提取吗？

是否可以将一些关系密切的字段封装在一个单独的类中（例如地址字段，例如街道、城市和国家/地区）。

字段数是否足够小？我会从不变性中受益吗？是否确定只有几个有效的可选字段组合，其余的可以用已知的默认值替换？在这种情况下应尽量保持简单并坚持只使用构造函数。

字段很多但不变性不那么重要？字段需要更改太多并且每次创建新实例的开销太大？也不涉及并发？这种情况应尽量采用的 JavaBeans 约定，只使用 setter 来构建对象。

我们关心我们构造的对象是不可变的吗？线程安全？应坚持使用 Builder 的方式。

对象构建过程复杂吗？过程是否可能保持不变（意味着涉及的步骤），但通过遵循相同的步骤顺序产生不同的输出（例如，针对不同的环境量身定制）可能会很方便？那么建造者模式可能是最佳方式。

### Builder 类自动生成插件

[innerbuilder](https://plugins.jetbrains.com/plugin/7354-innerbuilder)

将 Builder 操作添加到 Generate 菜单 (Alt+Insert) 中，它会生成一个内部构建器类，如 Effective Java 中所述

[Builder Generator](https://plugins.jetbrains.com/plugin/6585-builder-generator)

添加为类生成构建器并在它们之间切换的功能。在构建器和源类之间切换类似于“转到测试”操作。生成的构建器类不使用反射，只使用 setter 方法或构造函数。用法：

- 如果不存在则创建一个构建器
- 如果构建器存在，则在类和构建器之间切换
- ALT+SHIFT+B inside a file:
- **Code | Generate** menu (ALT+Insert) from a class:

- 如果不存在则创建一个构建器
- 如果存在，则重新生成构建器

## 经典实现

在本例中，我们想要构建英雄对象，但由于需要许多参数(武器、头发、盔甲)，其构造非常复杂。为了帮助用户，我们引入了Hero.Builder类。
Builder采用最小参数在其构造函数中构建 Hero 对象。之后，可以使用 Hero.Builder 完成 Hero 对象的附加配置。
当配置就绪时，调用build方法来接收最终的Hero对象

英雄配置

```java
public final class Hero {

  private final Profession profession; //职业
  private final String name; //名字
  private final HairType hairType; //头发类型
  private final HairColor hairColor; // 头发颜色
  private final Armor armor; //盔甲材质
  private final Weapon weapon; //武器

  private Hero(Builder builder) {
    this.profession = builder.profession;
    this.name = builder.name;
    this.hairColor = builder.hairColor;
    this.hairType = builder.hairType;
    this.weapon = builder.weapon;
    this.armor = builder.armor;
  }

  public Profession getProfession() {
    return profession;
  }

  public String getName() {
    return name;
  }

  public HairType getHairType() {
    return hairType;
  }

  public HairColor getHairColor() {
    return hairColor;
  }

  public Armor getArmor() {
    return armor;
  }

  public Weapon getWeapon() {
    return weapon;
  }

  @Override
  public String toString() {

    StringBuilder sb = new StringBuilder();
    sb.append("This is a ")
            .append(profession)
            .append(" named ")
            .append(name);
    if (hairColor != null || hairType != null) {
      sb.append(" with ");
      if (hairColor != null) {
        sb.append(hairColor).append(' ');
      }
      if (hairType != null) {
        sb.append(hairType).append(' ');
      }
      sb.append(hairType != HairType.BALD ? "hair" : "head");
    }
    if (armor != null) {
      sb.append(" wearing ").append(armor);
    }
    if (weapon != null) {
      sb.append(" and wielding a ").append(weapon);
    }
    sb.append('.');
    return sb.toString();
  }

  /**
   * The builder class.
   */
  public static class Builder {

    private final Profession profession;
    private final String name;
    private HairType hairType;
    private HairColor hairColor;
    private Armor armor;
    private Weapon weapon;


    public Builder(Profession profession, String name) {
      if (profession == null || name == null) { //必填参数添加非空判断
        throw new IllegalArgumentException("profession and name can not be null");
      }
      this.profession = profession;
      this.name = name;
    }

    public Builder withHairType(HairType hairType) {
      this.hairType = hairType;
      return this;
    }

    public Builder withHairColor(HairColor hairColor) {
      this.hairColor = hairColor;
      return this;
    }

    public Builder withArmor(Armor armor) {
      this.armor = armor;
      return this;
    }

    public Builder withWeapon(Weapon weapon) {
      this.weapon = weapon;
      return this;
    }

    public Hero build() {
      return new Hero(this);
    }
  }
}
```

测试类

```java
Hero mage = new Hero.Builder(Profession.MAGE, "孙悟空")
        .withHairColor(HairColor.BLACK)
        .withWeapon(Weapon.DAGGER)
        .build();
//This is a mage named 孙悟空 with black hair and wielding a dagger.
System.out.println(mage.toString());
Hero warrior = new Hero.Builder(Profession.WARRIOR, "李云龙")
        .withHairColor(HairColor.BLOND)
        .withHairType(HairType.LONG_CURLY).withArmor(Armor.CHAIN_MAIL).withWeapon(Weapon.SWORD)
        .build();
//This is a warrior named 李云龙 with blond long curly hair wearing chain mail and wielding a sword.
System.out.println(warrior.toString());

Hero thief = new Hero.Builder(Profession.THIEF, "后羿")
        .withHairType(HairType.BALD)
        .withWeapon(Weapon.BOW)
        .build();
//This is a thief named 后羿 with bald head and wielding a bow.
System.out.println(thief.toString());
```



## 谁在用建造者模式

### Java|StringBuilder/StringBuffer 

生成器在 Java 核心程序库中得到了广泛的应用：

- [`java.lang.StringBuilder#append()`](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#append-boolean-) （ `非同步` ）
- [`java.lang.StringBuffer#append()`](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-) （ `同步` ）

```java
private static void testStringBuilder() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("b")
            .append(new char[6])
            .append(1D);
    System.out.println(stringBuilder.toString());
}

private static void testStringBuffer() {
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append("a")
            .append(new char[3])
            .append(1);
    System.out.println(stringBuffer.toString());
}
```

### Android|AlertDialog

[AlertDialog.java](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/AlertDialog.java)

```kotlin
private fun buildDialog(context: Context) {
    // 创建构建器
    val builder: AlertDialog.Builder = AlertDialog.Builder(context)
    // 设置参数
    builder.setTitle("标题")
        .setMessage("内容")
        .setPositiveButton("确认按钮") { dialog, which -> TODO("Not yet implemented") }
        .setNegativeButton("取消按钮") { dialog, which -> TODO("Not yet implemented") }
        .setNeutralButton("不确定按钮") { dialog, which -> TODO("Not yet implemented") }
    // 创建 AlertDialog
    val create = builder.create()
    //显示 AlertDialog
    create.show()
}
```

### OkHttp|OkHttpClient

[OkhttpClient.kt](https://github.com/square/okhttp/blob/master/okhttp/src/main/kotlin/okhttp3/OkHttpClient.kt)

```kotlin
//简单实现
class OkHttpClient internal constructor(builder: Builder) {
    @get:JvmName("callTimeoutMillis")
    val callTimeoutMillis: Int = builder.callTimeout

    @get:JvmName("connectTimeoutMillis")
    val connectTimeoutMillis: Int = builder.connectTimeout

    constructor() : this(Builder())

    class Builder constructor() {

        internal var callTimeout = 0
        internal var connectTimeout = 10_000
        internal var proxy: Proxy? = null

        internal constructor(okHttpClient: OkHttpClient) : this() {
            this.callTimeout = okHttpClient.callTimeoutMillis
            this.connectTimeout = okHttpClient.connectTimeoutMillis
        }

        fun proxy(proxy: Proxy?) = apply {
            this.proxy = proxy
        }

        fun build(): OkHttpClient = OkHttpClient(this)
    }
}
```

[Request.kt](https://github.com/square/okhttp/blob/master/okhttp/src/main/kotlin/okhttp3/Request.kt)

```kotlin
//简单实现
class Request internal constructor(
    @get:JvmName("url") val url: String,
    @get:JvmName("method") val method: String,
) {
    
    open class Builder {
        internal var url: String? = null
        internal var method: String

        constructor() {
            this.method = "GET"
        }

        internal constructor(request: Request) {
            this.url = request.url
            this.method = request.method
        }

        open fun url(url: String): Builder {
            // Silently replace web socket URLs with HTTP URLs.
            val finalUrl: String = when {
                url.startsWith("ws:", ignoreCase = true) -> {
                    "http:${url.substring(3)}"
                }
                url.startsWith("wss:", ignoreCase = true) -> {
                    "https:${url.substring(4)}"
                }
                else -> url
            }
            return apply { this.url = finalUrl }
        }

        open fun build(): Request {
            return Request(
                checkNotNull(url) { "url == null" },
                method,
            )
        }
    }
}
```

```java

//构建 OkHttpClient
OkHttpClient client = new OkHttpClient
  .Builder()
  .proxy(Proxy.NO_PROXY)
  .build();

//构建 Request
Request request = new Request
  .Builder()
  .url("https://raw.github.com/square/okhttp/master/README.md")
  .build();

//请求服务端的数据
String responseStr = client
  .newCall(request)
  .execute()
  .body()
  .string();
```



### Retrofit

```java
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(API_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build();
```



```java
public class Retrofit {

    final String baseUrl;

    Retrofit(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    public static final class Builder {

        private @Nullable
        String baseUrl = "";

        Builder() {
        }

        Builder(Retrofit retrofit) {
            baseUrl = retrofit.baseUrl;
        }

        public Builder baseUrl(String baseUrl) {
            Objects.requireNonNull(baseUrl, "baseUrl == null");
            this.baseUrl = baseUrl;
            return this;
        }

        public Retrofit build() {
            if (baseUrl == null) {
                throw new IllegalStateException("Base URL required.");
            }
            return new Retrofit(baseUrl);
        }
    }
}
```

### javapoet|MethodSpec\TypeSpecJavaFile

[javapoet](https://github.com/square/javapoet)

```java
MethodSpec main = MethodSpec.methodBuilder("main")
    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
    .returns(void.class)
    .addParameter(String[].class, "args")
    .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")
    .build();

TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")
    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
    .addMethod(main)
    .build();

JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)
    .build();

javaFile.writeTo(System.out);
```



## 参考

- [极客时间| 设计模式之美](https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D)
- [慕课网 | java设计模式精讲 Debug 方式+内存分析](https://coding.imooc.com/class/270.html?mc_marking=6eab7b8c9bc28db4f23571353f1a9fe5&mc_channel=banner)
- [在线书籍 | 深入设计模式](https://refactoringguru.cn/design-patterns)
- [bugstack虫洞栈 | 实战设计模式](https://bugstack.cn/itstack/itstack-demo-design.html)
- [菜鸟教程 | 设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [Github | java-design-patterns](https://github.com/iluwatar/java-design-patterns)
- [Github | Design-Patterns-In-Kotlin](https://github.com/dbacinski/Design-Patterns-In-Kotlin)
- [Github | flutter-design-patterns](https://github.com/mkobuolys/flutter-design-patterns)

- [avoid-telescoping-constructor-pattern](https://www.vojtechruzicka.com/avoid-telescoping-constructor-pattern/)

