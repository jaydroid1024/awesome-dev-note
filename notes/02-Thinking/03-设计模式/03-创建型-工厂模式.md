# 实战设计模式-创建型-工厂模式

什么时候该用工厂模式？

相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？

单例模式和简单工厂模式的结合

## 工厂模式概述

### 工厂模式分类

一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。简单工厂模式可以看作是工厂方法模式的一种特例。

- 简单工厂\|Sample Factory
  - 当每个对象的创建逻辑都比较简单的时候，推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。
  - 如果确定你的工厂类只有一个，那么简化掉抽象类是肯定没问题的，我们只需要将对应的工厂方法改为静态方法即可，想这样的方式又称简单工厂或静态工厂模式，它是工厂方法模式的一个弱化版本。
  - 简单工厂通常没有子类。 但当从一个简单工厂中抽取出子类后， 它看上去就会更像经典的*工厂方法*模式了。
  - 简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤。

- 工厂方法\|Factory Method
  - 定义一个创建对象的接口，不同的工厂类实现该接口并封装各自的对象创建过程，工厂方法模式使对象的创建过程延迟到子类中进行。
  - 工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。
  - 如果在基类及其扩展的子类中都有一个构建方法的话， 那它可能就是工厂方法。
  - 每创建者添加一个新的工厂方法， 你就离抽象工厂模式更近一步。
  - 工厂方法模式结构
    - **创建者** （Creator） 返回产品对象的工厂方法的抽象层
    - **具体创建者** （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。
    - **产品** （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
    - **具体产品** （Concrete Products） 是产品接口的不同实现。

- 抽象工厂\|Abstract Factory
  - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
  - 什么是 “系列相关对象”？ 例如有这样一组的对象：  `运输工具`+ `引擎`+ `控制器` 。 它可能会有几个变体：
    1.  `汽车`+ `内燃机`+ `方向盘`
    2.  `飞机`+ `喷气式发动机`+ `操纵杆`
  - 抽象工⼚模式，所要解决的问题就是在一个产品族，存在多个不同类型的产品情况下，接口选择的问题。而这种场景在业务开发中也是非常多见的，只不过可能有时候没有将它们抽象化出来。
  - 抽象工厂是对工厂方法中工厂类的再抽象，例如对IRuleConfigParserFactory 的再抽象就是忽略 Rule 那就应该是IConfigParserFactory ，这里除了可以创建 Rule 还可以创建System、Biz 等 ConfigParserFactory。
  - 虽然抽象工厂方法模式的类繁多，但是，主要还是分为4类。
    - **AbstractFactory:抽象工厂角色**，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品。
    - **ConcreteFactory:具体工厂角色**，它实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成了一个产品种类，每一个产 品都位于某个产品等级结构中。
    - **AbstractProduct:抽象产品角色**，它为每种产品声明接口。
    - **ConcreteProduct:具体产品角色**，它定义具体工厂生产的具体产品对象，实现抽象产品接口中.
      声明的业务方法。
- 三个模式的演化流程大概如下图所示
  - [工厂模式详细比较](https://refactoringguru.cn/design-patterns/factory-comparison)

![image-20210921224632683](https://raw.githubusercontent.com/jaydroid1024/jay_image_repo/main/img/20210921224650.png)



### 使用工厂模式的参考标准

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。
- 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时可使用工厂方法。
- 如果你的程序中并不涉及产品系列的话， 那就不需要抽象工厂。
- **识别方法：** 工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。



## 简单工厂\|Sample Factory

### 模拟规则配置解析场景

我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig。这里需要设计实现一个RuleConfigParserFactory 用于创建不同类型的解析器。

**包含 if 分支逻辑的实现方式：**

```java
class RuleConfigParserFactory {
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
            parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
            parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
            parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
            parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。这有点类似单例模式和简单工厂模式的结合。

**缓存改进方案：预加载+缓存**

```java
class RuleConfigParserFactoryWithCache {
    private static final Map<String, IRuleConfigParser> cachedParsers = new HashMap<>();
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }
    //预加载+缓存
    public static IRuleConfigParser createParser(String configFormat) {
        if (configFormat == null || configFormat.isEmpty()) {
            return null;//返回null还是IllegalArgumentException全凭你自己说了算
        }
        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
        return parser;
    }  
}
```

**缓存改进方案：懒加载+缓存**

```java
class RuleConfigParserFactoryWithCache {
   private static final Map<String, IRuleConfigParser> lazyCachedParsers = new HashMap<>();
    //懒加载+缓存
    public static IRuleConfigParser createParser2(String configFormat) {
        if (configFormat == null || configFormat.isEmpty()) {
            return null;//返回null还是IllegalArgumentException全凭你自己说了算
        }
        if (!lazyCachedParsers.containsKey(configFormat)) {
            IRuleConfigParser parser = RuleConfigParserFactory.createParser(configFormat);
            lazyCachedParsers.put(configFormat, parser);
        }
        return lazyCachedParsers.get(configFormat.toLowerCase());
    }
}
```

调用方

```java
public static RuleConfig load(String ruleConfigFilePath) {
    //根据路径获取文件扩展名
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    //根据路径获取文件内容
    String ruleConfigFileContent = getFileContent(ruleConfigFilePath);


    //根据文件扩展名获取对应的解析器
    //todo 三种简单工厂实现
    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);
    IRuleConfigParser parserWithCache1 = RuleConfigParserFactoryWithCache.createParser(ruleConfigFileExtension);
    IRuleConfigParser parserWithCache2 = RuleConfigParserFactoryWithCache.createParser2(ruleConfigFileExtension);
    if (parser == null) {
        throw new InvalidParameterException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    System.out.println("parser:" + parser.getClass().getSimpleName());


    //配置规则解析器解析对应类型的文件并返回 RuleConfig
    return parser.parse(ruleConfigFileContent);
}
```



尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加parser，也没有太多的 parser）是没有问题的。

### 模拟炼金术士制造硬币的场景

工厂是一个创建其他对象的对象，它提供了一个静态方法来创建和返回不同类的对象，以隐藏实现逻辑并使客户端代码专注于使用而不是对象的初始化和管理。

在这个例子中，炼金术士制造硬币。 CoinFactory 是工厂类，它提供了一个静态方法来创建不同类型的硬币。

调用方

```java
Coin coin1 = CoinFactory.getCoin(CoinType.COPPER);
Coin coin2 = CoinFactory.getCoin(CoinType.GOLD);
System.out.println(coin1.getDescription());
System.out.println(coin2.getDescription());
```

工厂类

```java
public class CoinFactory {
  /**
   * Factory method takes as a parameter the coin type and calls the appropriate class.
   * 工厂方法将硬币类型作为参数并创建适当的类。
   */
  public static Coin getCoin(CoinType type) {
    Coin coin = null;
    if (type == CoinType.COPPER) {
      coin = new CopperCoin();
    } else if (type == CoinType.GOLD) {
      coin = new GoldCoin();
    }
    return coin;
  }
}
```

金币类

```java
public interface Coin {
  String getDescription();
}

public class GoldCoin implements Coin {
    static final String DESCRIPTION = "This is a gold coin.";
    @Override
    public String getDescription() {
        return DESCRIPTION;
    }
}

public class CopperCoin implements Coin {\
  static final String DESCRIPTION = "This is a copper coin.";
  @Override
  public String getDescription() {
    return DESCRIPTION;
  }
}

public enum CoinType {
  COPPER,
  GOLD
}
```

## 工厂方法\|Factory Method

### 模拟规则配置解析场景

同样以模拟解析不同类型的配置文件的需求看一下工厂方法模式的典型代码实现。

```java
public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
        return new JsonRuleConfigParser();
    }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
        return new XmlRuleConfigParser();
    }
}

class RuleConfigParserFactoryMap {

    private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();

    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
        cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
        cachedFactories.put("properties", new PropertiesRuleConfigParserFactory());
    }

    public static IRuleConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
        System.out.println("parserFactory:" + parserFactory.getClass().getSimpleName());
        return parserFactory;
    }
}
```

当我们需要添加新的规则配置解析器的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parserFactory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。

调用方

```java
public static RuleConfig load(String ruleConfigFilePath) {
    //根据路径获取文件扩展名
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    //根据路径获取文件内容
    String ruleConfigFileContent = getFileContent(ruleConfigFilePath);


    //根据文件扩展名获取对应的解析器
    //todo 工厂方法实现
    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    if (parserFactory == null) {
        throw new InvalidParameterException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser parser = parserFactory.createParser();
    System.out.println("parser:" + parser.getClass().getSimpleName());


    //配置规则解析器解析对应类型的文件并返回 RuleConfig
    return parser.parse(ruleConfigFileContent);
}
```

### 简单工厂与工厂方法应用场景

对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工方法厂模式更加合适。

当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。在这种情况下如果换成简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。所以在这种情况下应该使用工厂方法模式。



### 模拟铁匠锻造武器场景

在这个工厂方法示例中，我们有一个接口 Blacksmith(铁匠) ，其中包含一个用于创建对象的方法 manufactureWeapon。然后，具体的子类 OrcBlacksmith(兽人铁匠)，ElfBlacksmith(精灵铁匠) 重写该方法以生成它们各自需要创建的对象。

调用方

```java
//兽人铁匠-生成兽人武器的工厂
Blacksmith blacksmith = new OrcBlacksmith();
System.out.println(blacksmith);
//兽人长矛
Weapon weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);
System.out.println(weapon);
//兽人斧
weapon = blacksmith.manufactureWeapon(WeaponType.AXE);
System.out.println(weapon);
//精灵铁匠-生成精灵武器的工厂
blacksmith = new ElfBlacksmith();
System.out.println(blacksmith);
//精灵长矛
weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);
System.out.println(weapon);
//精灵斧
weapon = blacksmith.manufactureWeapon(WeaponType.AXE);
System.out.println(weapon);

//The orc blacksmith
//an orcish spear 兽人长矛
//an orcish axe 兽人斧
//The elf blacksmith
//an elven spear 精灵矛
//an elven axe 精灵斧
```

工厂类

```java
public interface Blacksmith {
  //制造武器
  Weapon manufactureWeapon(WeaponType weaponType);
}

@RequiresApi(api = Build.VERSION_CODES.N)
public class OrcBlacksmith implements Blacksmith {
  private static final Map<WeaponType, OrcWeapon> ORCARSENAL;
  static {
    //类加载时预先缓存所有武器
    ORCARSENAL = new EnumMap<>(WeaponType.class);
    Arrays.stream(WeaponType.values()).forEach(type -> ORCARSENAL.put(type, new OrcWeapon(type)));
  }
  @Override
  public Weapon manufactureWeapon(WeaponType weaponType) {
    return ORCARSENAL.get(weaponType);
  }
  @Override
  public String toString() {
    return "The orc blacksmith";
  }
}

@RequiresApi(api = Build.VERSION_CODES.N)
public class ElfBlacksmith implements Blacksmith {
  private static final Map<WeaponType, ElfWeapon> ELFARSENAL;
  static {
    ELFARSENAL = new EnumMap<>(WeaponType.class);
    Arrays.stream(WeaponType.values()).forEach(type -> ELFARSENAL.put(type, new ElfWeapon(type)));
  }
  @Override
  public Weapon manufactureWeapon(WeaponType weaponType) {
    return ELFARSENAL.get(weaponType);
  }
  @Override
  public String toString() {
    return "The elf blacksmith";
  }
}
```

武器相关

```java
public interface Weapon {
  WeaponType getWeaponType();
}

public class ElfWeapon implements Weapon {
  private final WeaponType weaponType;
  public ElfWeapon(WeaponType weaponType) {
    this.weaponType = weaponType;
  }
  @Override
  public String toString() {
    return "an elven " + weaponType;
  }
  @Override
  public WeaponType getWeaponType() {
    return weaponType;
  }
}

public class OrcWeapon implements Weapon {
  private final WeaponType weaponType;
  public OrcWeapon(WeaponType weaponType) {
    this.weaponType = weaponType;
  }
  @Override
  public String toString() {
    return "an orcish " + weaponType;
  }
  @Override
  public WeaponType getWeaponType() {
    return weaponType;
  }
}

public enum WeaponType {
    //短剑
    SHORT_SWORD("short sword"),
    //矛
    SPEAR("spear"),
    //斧头
    AXE("axe"),
    //未定义
    UNDEFINED("");
    private final String title;
    WeaponType(String s) {
        title = s;
    }
    @Override
    public String toString() {
        return title;
    }
}
```

## 抽象工厂\|Abstract Factory


### 模拟规则配置解析场景

抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。

```java
interface IConfigParserFactory {
    
    IRuleConfigParser createRuleParser();

    ISystemConfigParser createSystemParser();

    //此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new JsonRuleConfigParser();
    }

    @Override
    public ISystemConfigParser createSystemParser() {
        return new JsonSystemConfigParser();
    }
}

public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new XmlRuleConfigParser();
    }

    @Override
    public ISystemConfigParser createSystemParser() {
        return new XmlSystemConfigParser();
    }
}

class ConfigParserFactoryMap {

    private static final Map<String, IConfigParserFactory> cachedFactories = new HashMap<>();

    static {
        cachedFactories.put("json", new JsonConfigParserFactory());
        cachedFactories.put("xml", new XmlConfigParserFactory());
    }

    public static IConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        IConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
        System.out.println("parserFactory:" + parserFactory.getClass().getSimpleName());
        return parserFactory;
    }
}

```

调用方

```java
public static RuleConfig load(String parserType, String ruleConfigFilePath) {
    //根据路径获取文件扩展名
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    //根据路径获取文件内容
    String ruleConfigFileContent = getFileContent(ruleConfigFilePath);

    //根据文件扩展名获取对应的解析器
    //todo 抽象工厂实现
    IConfigParserFactory parserFactory = ConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    if (parserFactory == null) {
        throw new InvalidParameterException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser ruleParser = parserFactory.createRuleParser();
    ISystemConfigParser systemParser = parserFactory.createSystemParser();
    System.out.println("ruleParser:" + ruleParser.getClass().getSimpleName());
    System.out.println("systemParser:" + systemParser.getClass().getSimpleName());

    //配置规则解析器解析对应类型的文件并返回 RuleConfig
    if ("rule".equals(parserType)) {
        return ruleParser.parse(ruleConfigFileContent);
    } else {
        return systemParser.parse(ruleConfigFileContent);
    }
}
```

### 模拟王国创建场景

抽象工厂模式的本质是工厂接口（{@link KingdomFactory}）及其实现（{@link ElfKingdomFactory}，{@link OrcKingdomFactory}）。该示例使用这两种具体实现来创建不同的王国。王国的三要素：国王、城堡和军队。

调用方

```java
System.out.println("精灵王国");
//获取一个创建精灵王国的工厂
KingdomFactory elfKingdomFactory = KingdomFactoryMaker.makeFactory(KingdomType.ELF);
//封装精灵王国三元素
Kingdom elfKingdom = new Kingdom();
//创建国王
elfKingdom.setKing(elfKingdomFactory.createKing());
//创建城堡
elfKingdom.setCastle(elfKingdomFactory.createCastle());
//创建军队
elfKingdom.setArmy(elfKingdomFactory.createArmy());
System.out.println(elfKingdom.getArmy().getDescription());
System.out.println(elfKingdom.getCastle().getDescription());
System.out.println(elfKingdom.getKing().getDescription());

System.out.println("兽人王国");
//获取一个创建兽人王国的工厂
KingdomFactory orcKingdomFactory = KingdomFactoryMaker.makeFactory(KingdomType.ORC);
//封装兽人王国三元素
Kingdom orcKingdom = new Kingdom();
//创建国王
orcKingdom.setKing(orcKingdomFactory.createKing());
//创建城堡
orcKingdom.setCastle(orcKingdomFactory.createCastle());
//创建军队
orcKingdom.setArmy(orcKingdomFactory.createArmy());
System.out.println(orcKingdom.getArmy().getDescription());
System.out.println(orcKingdom.getCastle().getDescription());
System.out.println(orcKingdom.getKing().getDescription());

//精灵王国
//This is the elven army!
//This is the elven castle!
//This is the elven king!
//兽人王国
//This is the orc army!
//This is the orc castle!
//This is the orc king!
```

王国工厂类

```java
public interface KingdomFactory {
  Castle createCastle();
  King createKing();
  Army createArmy();
}

public class ElfKingdomFactory implements KingdomFactory {
  @Override
  public Castle createCastle() {
    return new ElfCastle();
  }
  @Override
  public King createKing() {
    return new ElfKing();
  }
  @Override
  public Army createArmy() {
    return new ElfArmy();
  }
}

public class OrcKingdomFactory implements KingdomFactory {
  @Override
  public Castle createCastle() {
    return new OrcCastle();
  }
  @Override
  public King createKing() {
    return new OrcKing();
  }
  @Override
  public Army createArmy() {
    return new OrcArmy();
  }
}
```

王国三要素

```java
public interface Army {
  String getDescription();
}
public interface Castle {
  String getDescription();
}
public interface King {
  String getDescription();
}

public class ElfArmy implements Army {
  static final String DESCRIPTION = "This is the elven army!";
  @Override
  public String getDescription() {
    return DESCRIPTION;
  }
}

public class ElfCastle implements Castle {
  static final String DESCRIPTION = "This is the elven castle!";
  @Override
  public String getDescription() {
    return DESCRIPTION;
  }
}

public class ElfKing implements King {
  static final String DESCRIPTION = "This is the elven king!";
  @Override
  public String getDescription() {
    return DESCRIPTION;
  }
}
```



## 工厂模式总结

当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。

针对创建逻辑比较复杂可以分为下面三种情况

- 根据不同的类型创建不同的对象
  - 类似规则配置解析的例子，代码中存在复杂的 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else创建对象的代码抽离出来，放到工厂类中。

- 单个对象本身的创建过程比较复杂
  - 尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。
- 以上两种情况的叠加
  - 单个对象本身的创建过程比较复杂并且这些复杂对象又区分不同维度时，这种情况下就推荐使用抽象工厂模式了。

对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，可以考虑使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。



## 实战工厂模式

###  DI 容器

依赖注入容器（Dependency Injection Container），简称 DI 容器。实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”

工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，DI 容器负责的是整个应用中所有类对象的创建。除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理等。

#### 容器的核心功能有哪些？

- 配置解析
  - 作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，通过配置实现解耦。
  - 我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。
- 对象创建
  - 将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。
  - 利用“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。
- 对象的生命周期管理
  - 简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。
  - 在DI容器框架中我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。
  - 还可以配置对象是否支持懒加载。通过lazy-init 标识。true 表示对象在真正被使用时才被被创建，false 表示对象在应用启动的时候就事先创建好
  - 还可以配置对象的 init-method 和 destroy-method 方法，DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件等。

核心 BeansFactory 实现方式

```java
class BeansFactory {
    private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();
    private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();

    public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {
        //将所有类信息提前缓存
        for (BeanDefinition beanDefinition : beanDefinitionList) {
            this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);
        }
        for (BeanDefinition beanDefinition : beanDefinitionList) {
            //预加载单例类提前缓存好
            if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) {
                createBean(beanDefinition);
            }
        }
    }

    /**
     * 简单工厂实现方式
     * 在同一个工厂类中根据 beanId 创建不同的 bean
     * @param beanId
     * @return
     */
    public Object getBean(String beanId) {
        BeanDefinition beanDefinition = beanDefinitions.get(beanId);
        if (beanDefinition == null) {
            throw new InvalidParameterException("Bean is not defined: " + beanId);
        }
        return createBean(beanDefinition);
    }

    protected Object createBean(BeanDefinition beanDefinition) {
        //通过 map 实现单例
        if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition)) {
            return singletonObjects.get(beanDefinition.getId());
        }
        Object bean = null;
        try {
            Class beanClass = Class.forName(beanDefinition.getClassName());
            List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();
            if (args.isEmpty()) {
                //无参构造
                bean = beanClass.newInstance();
            } else {
                //根据构造器参数构造 bean
                Class[] argClasses = new Class[args.size()]; //参数类型
                Object[] argObjects = new Object[args.size()]; //参数实例
                //遍历获取所有参数
                for (int i = 0; i < args.size(); ++i) {
                    BeanDefinition.ConstructorArg arg = args.get(i);
                    if (!arg.isRef()) {
                        argClasses[i] = arg.getType();
                        argObjects[i] = arg.getArg();
                    } else {
                        //引用类型参数
                        BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());
                        if (refBeanDefinition == null) {
                            throw new InvalidParameterException("Bean is not defined: " + refBeanDefinition);
                        }
                        argClasses[i] = Class.forName(refBeanDefinition.getClassName());
                        //递归创建引用类型
                        argObjects[i] = createBean(refBeanDefinition);
                    }
                }
                //指定构造器构造
                bean = beanClass.getConstructor(argClasses).newInstance(argObjects);
            }
        } catch (Exception e) {
            throw new InvalidParameterException(e.getLocalizedMessage());
        }
        //通过 map 实现单例
        if (bean != null && beanDefinition.isSingleton()) {
            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);
            return singletonObjects.get(beanDefinition.getId());
        }
        return bean;
    }
}
```

完整代码参考[这里]()





## 谁在用工厂模式

Java中的 Calendar、DateFormat 、java.text.NumberFormat是使用工厂模式实现的、Executors 利用静态方法做工厂方法

Android开发中工厂模式也很常用，比如`BitmapFactory`类



### Java|Calendar -简单工厂

```java
public class Calendar {
    java.util.Calendar cal = null;
    public Calendar(java.util.Calendar cal) {
        this.cal = cal;
    }
    @SuppressWarnings("NewApi")
    public static Calendar getInstance() {
        return createCalendar(TimeZone.getDefault(), Locale.getDefault());
    }
    @SuppressWarnings("NewApi")
    private static Calendar createCalendar(TimeZone zone, Locale aLocale) {
        java.util.Calendar cal = null;
        if (aLocale.hasExtensions()) {
            String caltype = aLocale.getUnicodeLocaleType("ca");
            if (caltype != null) {
                switch (caltype) {
                    case "buddhist":
                        cal = new BuddhistCalendar(zone, aLocale);
                        break;
                    case "gregory":
                        cal = new GregorianCalendar(zone, aLocale);
                        break;
                    default:
                        throw new IllegalStateException("Unexpected value: " + caltype);
                }
            }
        }
        if (cal == null) {
            if ("th".equals(aLocale.getLanguage()) && aLocale.getCountry() == "TH") {
                cal = new BuddhistCalendar(zone, aLocale);
            } else {
                cal = new GregorianCalendar(zone, aLocale);
            }
        }
        //这里包装Java 的 Calendar 利于测试
        return new Calendar(cal);
    }

    public java.util.Calendar getCal() {
        return cal;
    }
    
    //public class GregorianCalendar extends Calendar {
    //public class BuddhistCalendar extends GregorianCalendar {
}


//测试代码
//内部通过简单工厂模式创建的的不同的 Calendar GregorianCalendar 或者 BuddhistCalendar
//createCalendar 静态方法就是工厂创建方法
Calendar calendar = Calendar.getInstance();
Date time = calendar.getCal().getTime();
System.out.println("time:" + time);
```

### Java|NumberFormat-简单工厂

```java
private static NumberFormat getInstance(LocaleProviderAdapter adapter,
                                        Locale locale, int choice) {
    NumberFormatProvider provider = adapter.getNumberFormatProvider();
    NumberFormat numberFormat = null;
    switch (choice) {
    case NUMBERSTYLE:
        numberFormat = provider.getNumberInstance(locale);
        break;
    case PERCENTSTYLE:
        numberFormat = provider.getPercentInstance(locale);
        break;
    case CURRENCYSTYLE:
        numberFormat = provider.getCurrencyInstance(locale);
        break;
    case INTEGERSTYLE:
        numberFormat = provider.getIntegerInstance(locale);
        break;
    }
    return numberFormat;
}
```

DateFormat

```java
private static DateFormat get(LocaleProviderAdapter adapter, int timeStyle, int dateStyle, Locale loc) {
    DateFormatProvider provider = adapter.getDateFormatProvider();
    DateFormat dateFormat;
    if (timeStyle == -1) {
        dateFormat = provider.getDateInstance(dateStyle, loc);
    } else {
        if (dateStyle == -1) {
            dateFormat = provider.getTimeInstance(timeStyle, loc);
        } else {
            dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);
        }
    }
    return dateFormat;
}
```



### Dagger2-

Android|ViewModel



## 参考

- [极客时间| 设计模式之美](https://time.geekbang.org/column/intro/250?code=Grxvvkczx9tydhzn0RhJfNfwaF2RgJA9qeUWd8orIYo%3D)
- [慕课网 | java设计模式精讲 Debug 方式+内存分析](https://coding.imooc.com/class/270.html?mc_marking=6eab7b8c9bc28db4f23571353f1a9fe5&mc_channel=banner)
- [在线书籍 | 深入设计模式](https://refactoringguru.cn/design-patterns)
- [bugstack虫洞栈 | 实战设计模式](https://bugstack.cn/itstack/itstack-demo-design.html)
- [菜鸟教程 | 设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
- [Github | java-design-patterns](https://github.com/iluwatar/java-design-patterns)
- [Github | Design-Patterns-In-Kotlin](https://github.com/dbacinski/Design-Patterns-In-Kotlin)
- [Github | flutter-design-patterns](https://github.com/mkobuolys/flutter-design-patterns)

