## BaseDev筑基系列-编译原理小抄





## 概述篇

### 编译原理概述

- 目的以及作用
  - 研究「翻译」的科学，把一种机器语言翻译成另一种机器语言
    - 例如:高级语言->低级语言->机器语言
    - 例如:计算机语言->硬件设备
  - 让计算机理解更高级的语言并执行
  - 让计算机理解人，给人提供更好的思考方式。
  - 专家系统(prolog)
  - 内置脚本(Lua, javascript)
  - 领域建模(HTML, SQL,业务语言)
- 翻译的理解
  - 编译原理的「翻译」能力只能作用在形式语言上
    - 我看复仇者联盟电影。如何理解？
  - 计算机语言提供给了我们新的思考方式
    - 例如:基于OOP语言我们思考领域一万事万物
    - 例如:基于FP我们思考领域转化一规律
  - 计算机和人是相辅相成的关系
- 编译器VS解释器
  - 编译器
    - 源程序-->编译器--->目标程序
    - 编译器将源程序编译成目标程序
  - 程序的执行
    - 输入-->程序-->输出
    - 程序可以看作一个函数， 接受输入和返回输出
  - 解释器
    - 源程序+输入--->解释器--->输出
    - 解释器同时接受源程序和输入，执行并返回输出
    - 早期javascript是解释执行 
  - 混合编译器
    - 源程序-->第一次编泽--->中间代码--->第二次编译+输入--->虚拟机--->输出
    - 中间代码更容易被翻译成目标程序、优化空间更大
    - 中间语言的存在更利于编译器的实现
    - 让虚拟机处理复杂的执行环境(跨平台)
  - 即时编译器(Just-in-time compiler)
    - 一种提高效率的方法， 中间代码不是直接执行，而是先被编译成机器码再执行。
    - 例如: Java的一个类的字节码第一次执行时被编译成了机器码， 第二次执行的时候不需要再编译。
    - 优点:提高执行效率(50%以上)
  - 交叉编译
    - 在一个平台编译产生多个平台的可执行代码
      - Windows X86--->{Linux ARM / Mac OS ARM 64}
  - 不同方式优劣势
    - 解释执行有性能问题，但也异常灵活，例如支持eval函数，意味着程序可以动态修改。
    - 直接交叉编译技术难度是其次，跨平台问题会多; -次编译很多包也有分发问题。
    - 虚拟化技术提供了更好的体验，却没有提供更好的性能(JIT完美解决这一点)

- 编译的流程
  - 词法分析
    - 词法分析是一个分词断句+判断词性的过程。
    - 词法分析将源代码的字符流转成符号流。
    - `var a =1=4*5`
  - 语法分析
    - 根据词法分析结果形成抽象语法树( Abstract Syntax Tree, ab. AST)的过程
    - 语法规则
    - 语义分析-检查语法
  - 翻译成中间代码
  - 生成机器码
  - 运行时环境
    - 有的编译器将代码编译成机器码，按照操作系统的约定编译成一个应用，运行成为操作系统的进程。
    - 有的编译器将代码编译成中间代码(字节码、三地址代码等)， 然后在操作系统中启动一个虚拟容器(进程)来执行他们。
    - JIT编译器边执行中间代码，边编译他们。
  - 编译器处理的两大过程
    - 分析
      - 对源程序进行分析形成中间表示(抽象语法树、符号表)
      - 词法分析
      - 语法分析
      - 语义分析
      - 翻译
    - 综合
      - 根据中间表示生成目标语言，提供运行环境等
      - 中间语言
      - 代码优化
      - 机器码生成
      - 运行环境及其他
  - 分层设计
    - 最常见的软件架构
    - 真正实现优质的分层设计却很难
      - 难点1：关注度分离，每一层都有意义有产出，可以独立使用。
      - 难点2：层足够强大，每一层都用优质的算法、数据结构、架构技巧解决大量共性问题。



## 词法分析：Lexer

### 词法分析器简介

- 将字符流转成符号流。输入:源代码(字符流) 输出:符号流
- 词法分析过程类似我们中学语文学习的「词性标注」，每个符号是一个元组，应该至少包括一个字符串和一个词性描述。
- 例如：`var a =1=4*5`

| var     | a        | =        | 1       | +        | 4       | *        | 5       |
| ------- | -------- | -------- | ------- | -------- | ------- | -------- | ------- |
| Keyword | Variable | Operator | Integer | Operator | Integer | Operator | Integer |

- 符号（词法单元）
  - 词法分析器的结果是一个个的符号，英文Token,也叫词法单元。
  - 数学上符号是一个元组，例如整数123我们可以表示为(123，Integer)。
- TinyScript中有这些符号类型
  - Keyword(关键字)
  - Variable(变量)
  - Operator (操作符)
  - Bracket (括号)
  - String(字符串)
  - Float(浮点数）
  - Boolean(布尔)

### 词法分析器的基本接口

- 实现符号类型枚举
  - TokenType
  - Token
- 实现关键词字典
- 定义词法分析器的程序接口





- 编译器基础能力设计一实现流的peek和putBack操作
- Java：实现流的peek和putBack操作
- Javascript：实现流的peek和putBack操作
- 坚持编写测试用例
- 词法相关理论和正则
- Java：有穷状态机实现词语提取
- Javascript：有穷状态机实现词语提取
- Java：完整的词法分析器
- Javascript：完整的词法分析器



## 语法分析

- 数据结构引导：树和抽象语法树
- (parser01 java)定义抽象语法树
- (parser01 javascript)定义抽象语法树
- 最简表达式分析过程
- (编程parser02 java)-实现最简Parser
- (编程parser02 javascript-- -实现最简Parser
- TinyScript表达式解析-优先级和去左递归
- (编程parser03 java) TinyScript表达式解析
- (编程parser03 javascript) TinyScript表达式解析
- (编程parser04 java)树的后序遍历：表达式验证
- (编程parser04 javascript) 树的后序遍历：表达式验证
-  (编程parse05 java)语法分析整体程序
- (编程parser05 javascript) 语法分析整体程序

- 那些穿插在迭代中的重构
- 大批递归来袭之应对
- 词法语法部分总结一 领域驱动视角



## 语法制导翻译

- 综合部分序章：三 地址代码
- 构造三地址代码一基于SDD的翻译
- 词法作用域和符号表
- (编程trans 01 java)实现符号表
- (编程trans 01 javascript)实现符号表
- 三地址代码的表示
- 编程trans02 java)三地址代码的表示
- (编程trans02 javascript)三地址代码的表示
- 翻译的整体过程和表达式
- (编程trans 03 java) 翻译的整体过程和表达式
- (编程trans 03 javascript)翻译的整体过程和表达式
- 翻译一 作用域的处理
- (编程trans 04 java)翻译一作用域和整体程序
- (编程trans 04 javascript)翻译一作用域和整体程序



## 程序运行环境

- 用虚拟机执行TinyScript程序
- (编程java vm 01)指令和程序表示
- 生成器：将三地址代码转化成指令
- (编程java vm 02)指令翻译过程讲解
- (编程java vm 02)神奇的位运算
- (编程java vm 03)虚拟机一指令的编码和解码
- (编程java vm 04)虚拟机执行程序
- 课程总结一如何做一 个优秀的架构师

